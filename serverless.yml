# ClaimIQ Serverless Application Configuration
# This handles Lambda functions, API routes, and event handlers
# Infrastructure resources are managed by Terraform

service: claimiq-ingestion

frameworkVersion: '3'

# YAML Anchors for reusability
x-common-cors: &common-cors
  origin: '*'
  headers:
    - Content-Type
    - X-Amz-Date
    - Authorization
    - X-Api-Key
    - X-Amz-Security-Token
    - X-Tenant-Id
    - X-Hospital-Id
  allowCredentials: false

x-upload-cors: &upload-cors
  origin: '*'
  headers:
    - Content-Type
    - X-Amz-Date
    - Authorization
    - X-Api-Key
    - X-Amz-Security-Token
  allowCredentials: false

x-custom-authorizer: &custom-authorizer
  name: authorizer
  type: request
  resultTtlInSeconds: 300
  identitySource: method.request.header.Authorization
  identityValidationExpression: '^Bearer [-0-9a-zA-Z\._]*$'

x-lambda-defaults: &lambda-defaults
  runtime: nodejs18.x
  memorySize: 1024
  timeout: 300

provider:
  name: aws
  runtime: nodejs18.x
  region: ${opt:region, 'us-east-1'}
  stage: ${opt:stage, 'dev'}
  memorySize: 1024
  timeout: 300
  
  # Environment variables (populated from environment JSON file)
  environment:
    ENVIRONMENT: ${self:provider.stage}
    CLAIMS_BUCKET_NAME: ${file(env-${self:provider.stage}.json):CLAIMS_BUCKET_NAME}
    AURORA_CLUSTER_ARN: ${file(env-${self:provider.stage}.json):AURORA_CLUSTER_ARN}
    AURORA_SECRET_ARN: ${file(env-${self:provider.stage}.json):AURORA_SECRET_ARN}
    AGENT_LOGS_TABLE: ${file(env-${self:provider.stage}.json):AGENT_LOGS_TABLE}
    DATABASE_NAME: ${file(env-${self:provider.stage}.json):DATABASE_NAME}
    USER_POOL_ID: ${file(env-${self:provider.stage}.json):USER_POOL_ID}
    USER_POOL_CLIENT_ID: ${file(env-${self:provider.stage}.json):USER_POOL_CLIENT_ID}
    MAX_FILE_SIZE_MB: 50
  
  # IAM role (managed by Terraform)
  role: ${file(env-${self:provider.stage}.json):LAMBDA_EXECUTION_ROLE_ARN}
  
  # VPC configuration (managed by Terraform)
  vpc:
    securityGroupIds:
      - ${file(env-${self:provider.stage}.json):LAMBDA_SECURITY_GROUP_ID}
    subnetIds: ${file(env-${self:provider.stage}.json):PRIVATE_SUBNET_IDS}
  
  # API Gateway configuration (reference existing from Terraform)
  apiGateway:
    restApiId: ${file(env-${self:provider.stage}.json):API_GATEWAY_ID}
    restApiRootResourceId: ${file(env-${self:provider.stage}.json):API_GATEWAY_ROOT_RESOURCE_ID}
  
  # Tracing
  tracing:
    lambda: true
  
  # Logs (disabled for external API Gateway)
  # logs:
  #   restApi: true

# Package configuration - Serverless handles TypeScript compilation automatically
package:
  patterns:
    - '!.git/**'
    - '!.gitignore'
    - '!README.md'
    - '!terraform/**'
    - '!.serverless/**'
    - '!*.zip'
    - '!**/*.test.ts'
  individually: true

functions:
  # Lambda Authorizer Function (JWT validation)
  authorizer:
    <<: *lambda-defaults
    handler: src/lambda/authorizer/index.handler
    name: ${self:provider.stage}-claimiq-authorizer
    description: 'ClaimIQ JWT authorizer for API Gateway authentication (TypeScript)'
    memorySize: 512
    timeout: 30
    environment:
      FUNCTION_NAME: authorizer
      USER_POOL_ID: ${file(env-${self:provider.stage}.json):USER_POOL_ID}
      USER_POOL_CLIENT_ID: ${file(env-${self:provider.stage}.json):USER_POOL_CLIENT_ID}
    # No HTTP events - used as authorizer only

  # File Upload Function (Pre-signed URL generation)
  fileUpload:
    <<: *lambda-defaults
    handler: src/lambda/file_upload/index.handler
    name: ${self:provider.stage}-claimiq-file-upload
    description: 'ClaimIQ pre-signed URL generator for direct S3 uploads (TypeScript)'
    environment:
      FUNCTION_NAME: file-upload
    events:
      # Uses custom authorizer with YAML anchor for reusability
      - http:
          path: upload
          method: post
          authorizer: *custom-authorizer
          cors: *common-cors
      - http:
          path: upload/{claimId}
          method: get
          authorizer: *custom-authorizer
          cors: *upload-cors

  # S3 Event Processor Function (Triggered by S3 uploads)
  s3Processor:
    <<: *lambda-defaults
    handler: src/lambda/s3_processor/index.handler
    name: ${self:provider.stage}-claimiq-s3-processor
    description: 'ClaimIQ S3 event processor - triggers workflow on file upload (TypeScript)'
    environment:
      FUNCTION_NAME: s3-processor
      # STEP_FUNCTION_ARN will be added after Step Functions deployment
    # S3 events will be added after initial deployment
    # events:
    #   # S3 bucket event trigger
    #   - s3:
    #       bucket: ${file(env-${self:provider.stage}.json):CLAIMS_BUCKET_NAME}
    #       event: s3:ObjectCreated:*
    #       rules:
    #         - prefix: tenants/
    #         - suffix: .pdf

  # Health Check Function (No authorization needed)
  healthCheck:
    <<: *lambda-defaults
    handler: src/lambda/file_upload/index.healthHandler
    name: ${self:provider.stage}-claimiq-health
    description: 'ClaimIQ API health check endpoint (TypeScript)'
    memorySize: 256
    timeout: 10
    environment:
      FUNCTION_NAME: health-check
    events:
      - http:
          path: health
          method: get
          cors:
            origin: '*'
            headers:
              - Content-Type
            allowCredentials: false



# Custom resources and outputs
resources:
  Outputs:
    FileUploadLambdaArn:
      Description: "File Upload Lambda Function ARN"
      Value:
        Fn::GetAtt: [FileUploadLambdaFunction, Arn]
      Export:
        Name: ${self:provider.stage}-claimiq-file-upload-arn
    
    S3ProcessorLambdaArn:
      Description: "S3 Processor Lambda Function ARN"
      Value:
        Fn::GetAtt: [S3ProcessorLambdaFunction, Arn]
      Export:
        Name: ${self:provider.stage}-claimiq-s3-processor-arn

# Plugins
plugins:
  - serverless-plugin-typescript
  - serverless-offline

# Custom configuration
custom:
  # TypeScript plugin configuration
  serverless-plugin-typescript:
    tsConfigFileLocation: './tsconfig.json'
  
  # Serverless Offline configuration
  serverless-offline:
    httpPort: 3000
    lambdaPort: 3002
    websocketPort: 3001
    noPrependStageInUrl: true
    noAuth: false
    printOutput: true
    # Use real AWS services (not local emulation)
    useChildProcesses: true